Index: speech-dispatcher/src/python/speechd/__init__.py
===================================================================
--- speech-dispatcher.orig/src/python/speechd/__init__.py	2012-06-27 13:41:13.427774878 +1000
+++ speech-dispatcher/src/python/speechd/__init__.py	2012-06-27 13:41:55.859775964 +1000
@@ -14,5 +14,5 @@
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 
-from client import *
+from .client import *
 
Index: speech-dispatcher/src/python/speechd/_test.py
===================================================================
--- speech-dispatcher.orig/src/python/speechd/_test.py	2012-06-27 13:41:13.427774878 +1000
+++ speech-dispatcher/src/python/speechd/_test.py	2012-06-27 13:41:55.859775964 +1000
@@ -19,7 +19,7 @@
 import unittest
 import time
 
-from client import PunctuationMode, CallbackType, SSIPClient, Scope, Speaker
+from .client import PunctuationMode, CallbackType, SSIPClient, Scope, Speaker
 
 
 class _SSIPClientTest(unittest.TestCase):
@@ -124,10 +124,10 @@
          c = self._client
          for module in  c.list_output_modules():
              c.set_output_module(module)
-             print "**", module
+             print("**", module)
              c.speak(module +"using default voice")
              for name, lang, dialect in c.list_synthesis_voices():
-                 print " -", module, name, lang, dialect
+                 print(" -", module, name, lang, dialect)
                  c.set_synthesis_voice(name)
                  c.speak(module +" using voice "+ name)
         
Index: speech-dispatcher/src/python/speechd/client.py
===================================================================
--- speech-dispatcher.orig/src/python/speechd/client.py	2012-06-27 13:41:13.427774878 +1000
+++ speech-dispatcher/src/python/speechd/client.py	2012-06-27 13:41:55.863775964 +1000
@@ -32,7 +32,7 @@
 except:
     import dummy_threading as threading
 
-import paths
+from . import paths
     
 class CallbackType(object):
     """Constants describing the available types of callbacks"""
@@ -151,9 +151,9 @@
 class _SSIP_Connection(object):
     """Implemantation of low level SSIP communication."""
     
-    _NEWLINE = "\r\n"
-    _END_OF_DATA_MARKER = '.'
-    _END_OF_DATA_MARKER_ESCAPED = '..'
+    _NEWLINE = b"\r\n"
+    _END_OF_DATA_MARKER = b'.'
+    _END_OF_DATA_MARKER_ESCAPED = b'..'
     _END_OF_DATA = _NEWLINE + _END_OF_DATA_MARKER + _NEWLINE
     _END_OF_DATA_ESCAPED = _NEWLINE + _END_OF_DATA_MARKER_ESCAPED + _NEWLINE
     # Constants representing \r\n. and \r\n..
@@ -187,12 +187,12 @@
         try:
             self._socket = socket.socket(socket_family, socket.SOCK_STREAM)
             self._socket.connect(socket_connect_args)
-        except socket.error, ex:
+        except socket.error as ex:
             raise SSIPCommunicationError("Can't open socket using method "
                                          + communication_method,
                                          original_exception = ex)
 
-        self._buffer = ""
+        self._buffer = b""
         self._com_buffer = []
         self._callback = None
         self._ssip_reply_semaphore = threading.Semaphore(0)
@@ -232,7 +232,7 @@
             except IOError:
                 # If the socket has been closed, exit the thread
                 sys.exit()
-            if code/100 != 7:
+            if code//100 != 7:
                 # This is not an index mark nor an event
                 self._com_buffer.append((code, msg, data))
                 self._ssip_reply_semaphore.release()
@@ -267,7 +267,7 @@
             pointer = self._buffer.find(self._NEWLINE)
         line = self._buffer[:pointer]
         self._buffer = self._buffer[pointer+len(self._NEWLINE):]
-        return line
+        return line.decode('utf-8')
 
     def _recv_message(self):
         """Read server response or a callback
@@ -321,11 +321,11 @@
                        or isinstance(args[0], int)
         cmd = ' '.join((command,) + tuple(map(str, args)))
         try:
-            self._socket.send(cmd + self._NEWLINE)
+            self._socket.send(cmd.encode('utf-8') + self._NEWLINE)
         except socket.error:
             raise SSIPCommunicationError("Speech Dispatcher connection lost.")
         code, msg, data = self._recv_response()
-        if code/100 != 2:
+        if code//100 != 2:
             raise SSIPCommandError(code, msg, cmd)
         return code, msg, data
         
@@ -340,6 +340,7 @@
         'IOError' is raised when the socket was closed by the remote side.
         
         """
+        data = data.encode('utf-8')
         # Escape the end-of-data marker even if present at the beginning
         # The start of the string is also the start of a line.
         if data.startswith(self._END_OF_DATA_MARKER):
@@ -357,7 +358,7 @@
         except socket.error:
             raise SSIPCommunicationError("Speech Dispatcher connection lost.")
         code, msg, response_data = self._recv_response()
-        if code/100 != 2:
+        if code//100 != 2:
             raise SSIPDataError(code, msg, data)
         return code, msg, response_data
 
@@ -576,14 +577,14 @@
         """Establish new connection (and/or autospawn server)"""
         try:
             self._conn = _SSIP_Connection(**connection_args)
-        except SSIPCommunicationError, ce:
+        except SSIPCommunicationError as ce:
             # Suppose server might not be running, try the autospawn mechanism
             if autospawn != False:
                 # Autospawn is however not guaranteed to start the server. The server
                 # will decide, based on it's configuration, whether to honor the request.
                 try:
                     self._server_spawn(connection_args)
-                except SpawnError, se:
+                except SpawnError as se:
                     ce.set_additional_exception(se)
                     raise ce
                 self._conn = _SSIP_Connection(**connection_args)
@@ -737,8 +738,6 @@
 
         """
         self._conn.send_command('SPEAK')
-        if isinstance(text, unicode):
-            text = text.encode('utf-8')
         result = self._conn.send_data(text)
         if callback:
             msg_id = int(result[2][0])
@@ -759,8 +758,6 @@
         message is queued on the server and the method returns immediately.
 
         """
-        if isinstance(char, unicode):
-            char = char.encode('utf-8')
         self._conn.send_command('CHAR', char.replace(' ', 'space'))
         
     def key(self, key):
Index: speech-dispatcher/src/python/speechd_config/__init__.py
===================================================================
--- speech-dispatcher.orig/src/python/speechd_config/__init__.py	2012-06-27 13:41:13.427774878 +1000
+++ speech-dispatcher/src/python/speechd_config/__init__.py	2012-06-27 13:41:55.863775964 +1000
@@ -14,5 +14,5 @@
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 
-from config import *
+from .config import *
 
Index: speech-dispatcher/src/python/speechd_config/config.py
===================================================================
--- speech-dispatcher.orig/src/python/speechd_config/config.py	2012-06-27 13:41:13.427774878 +1000
+++ speech-dispatcher/src/python/speechd_config/config.py	2012-06-27 13:42:32.451776898 +1000
@@ -28,12 +28,12 @@
 from optparse import OptionParser
 
 # Configuration and sound data paths
-import paths
+from . import paths
 
 def report(msg):
     """Output information messages for the user on stdout
     and if desired, by espeak synthesis"""
-    print msg
+    print(msg)
     if options.use_espeak_synthesis:
         os.system("espeak \"" + msg + "\"")
 
@@ -57,7 +57,7 @@
         input_audio_icon()
 
         if not options.dont_ask:
-            str_inp = raw_input(">") 
+            str_inp = input(">")
 
         # On plain enter, return default
         if options.dont_ask or (len(str_inp) == 0):
@@ -213,17 +213,17 @@
 and problem diagnostics."""
         self.cmdline_parser = OptionParser(usage)
 
-        for option, definition in self._conf_options.iteritems():
+        for option, definition in self._conf_options.items():
             # Set object attributes to default values
             def_val = definition.get('default', None)
             setattr(self, option, def_val)
             
             # Fill in the cmdline_parser object
-            if definition.has_key('command_line'):
+            if 'command_line' in definition:
                 descr = definition.get('descr', None)                
                 type = definition.get('type', None)
                 
-                if definition.has_key('arg_map'):
+                if 'arg_map' in definition:
                     type, map = definition['arg_map']
                 if type == str:
                     type_str = 'string'
@@ -248,10 +248,10 @@
         # Set options according to command line flags
         (cmdline_options, args) = self.cmdline_parser.parse_args()
 
-        for option, definition in self._conf_options.iteritems():
+        for option, definition in self._conf_options.items():
                 val = getattr(cmdline_options, option, None)
                 if val != None:
-                    if definition.has_key('arg_map'):
+                    if 'arg_map' in definition:
                         former_type, map = definition['arg_map']
                         try:
                             val = map[val]
@@ -298,7 +298,8 @@
         self.festival_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
         try:
             self.festival_socket.connect((socket.gethostbyname(host), port))
-        except socket.error, (num, reson):
+        except socket.error as e:
+            (num, reson) = e.args
             report("""ERROR: It was not possible to connect to Festival on the
 given host and port. Connection failed with error %d : %s .""" % (num, reson))
             report("""Hint: Most likely, your Festival server is not running now
@@ -500,18 +501,18 @@
         report("""
 
 Diagnostics results:""")
-        if results.has_key('spd_say_working'):
+        if 'spd_say_working' in results:
             if results['spd_say_working']:
                 report("Speech Dispatcher is working")
             else:
                 report("Speech Dispatcher not working through spd-say")
-        if results.has_key('synthesizers'):
+        if 'synthesizers' in results:
             report("Synthesizers that were tested and seem to work: %s" %
                    str(results['synthesizers']))
-        if results.has_key('audio'):
+        if 'audio' in results:
             report("Audio systems that were tested and seem to work: %s" %
                    str(results['audio']))
-        if results.has_key('python_speechd'):
+        if 'python_speechd' in results:
             if(results['python_speechd']):
                 report("Python Speech Dispatcher module is importable")
             else:
@@ -562,7 +563,7 @@
         time.sleep(2)
 
         # All debugging files are written to TMPDIR/speech-dispatcher/
-        if os.environ.has_key('TMPDIR'):
+        if 'TMPDIR' in os.environ:
             tmpdir = os.environ['TMPDIR']
         else:
             tmpdir = "/tmp/"
@@ -639,7 +640,7 @@
         # Parse config file in-place and replace the desired options+values
         for line in fileinput.input(configfile, inplace=True, backup=".bak"):
             # Check if the current line contains any of the desired options
-            for opt, value in options.iteritems():
+            for opt, value in options.items():
                 if opt in line:
                     # Now count unknown words and try to judge if this is
                     # real configuration or just a comment
@@ -671,11 +672,11 @@
                         else:
                             spd_val = str(value)
                             
-                        print opt + "   " + spd_val
+                        print(opt + "   " + spd_val)
                         break
             
             else:
-                print line,
+                print(line, end=' ')
                 
     def create_user_configuration(self):
         """Create user configuration in the standard location"""
Index: speech-dispatcher/src/python/speechd_config/spd-conf
===================================================================
--- speech-dispatcher.orig/src/python/speechd_config/spd-conf	2012-06-27 13:41:13.427774878 +1000
+++ speech-dispatcher/src/python/speechd_config/spd-conf	2012-06-27 13:41:55.863775964 +1000
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/python3
 
 # Helper script to be put in /usr/bin/ or a similar location
 # calling the appropriate python tool
Index: speech-dispatcher/configure.in
===================================================================
--- speech-dispatcher.orig/configure.in	2012-02-06 13:44:16.000000000 +1100
+++ speech-dispatcher/configure.in	2012-06-27 13:45:53.075782037 +1000
@@ -27,12 +27,12 @@
 AC_HEADER_TIME
 
 # Python support
-# Python 2.4 or greater should be acceptable.
+# Python 3 or greater required
 AS_IF([test $enable_python != "no"],
-	[AM_PATH_PYTHON([2.4],
+	[AM_PATH_PYTHON([3.0],
 		[enable_python=yes],
 		[AS_IF([test $enable_python = "yes"],
-		[AC_MSG_FAILURE([python is not available])])])])
+		[AC_MSG_FAILURE([python 3 or greater is not available])])])])
 AM_CONDITIONAL([HAVE_PYTHON], [test "$enable_python" = 'yes'])
 
 dnl Checks for library functions.
